import numpy as np
from scipy.spatial.distance import cdist
from sklearn.base import BaseEstimator
from typing import Union

# TODO: is currently being implemented
class Sammon(BaseEstimator):

    def __init__(
        self,
        n_components: Union[int, None],
        inputdist: str = 'raw',
        maxhalves: int = 20,
        max_iter: int = 500,
        tolfun: float = 1e-9,
        init: str = 'default'
    ):

        self.n_components = n_components
        self.inputdist = inputdist
        self.maxhalves = maxhalves
        self.max_iter = max_iter
        self.tolfun = tolfun
        self.init = init
        self.display = 2


    def fit_transform(self, data_high): #, n, display = 2, inputdist = 'raw', maxhalves = 20, maxiter = 500, tolfun = 1e-9, init = 'default'):

        """Perform Sammon mapping on dataset x
        y = sammon(x) applies the Sammon nonlinear mapping procedure on
        multivariate data x, where each row represents a pattern and each column
        represents a feature.  On completion, y contains the corresponding
        co-ordinates of each point on the map.  By default, a two-dimensional
        map is created.  Note if x contains any duplicated rows, SAMMON will
        fail (ungracefully).
        [y,E] = sammon(x) also returns the value of the cost function in E (i.e.
        the stress of the mapping).
        An N-dimensional output map is generated by y = sammon(x,n) .
        A set of optimisation options can be specified using optional
        arguments, y = sammon(x,n,[OPTS]):
           maxiter        - maximum number of iterations
           tolfun         - relative tolerance on objective function
           maxhalves      - maximum number of step halvings
           input          - {'raw','distance'} if set to 'distance', X is
                            interpreted as a matrix of pairwise distances.
           display        - 0 to 2. 0 least verbose, 2 max verbose.
           init           - {'pca', 'cmdscale', random', 'default'}
                            default is 'pca' if input is 'raw',
                            'msdcale' if input is 'distance'
        The default options are retrieved by calling sammon(x) with no
        parameters.
        File        : sammon.py
        Date        : 18 April 2014
        Authors     : Tom J. Pollard (tom.pollard.11@ucl.ac.uk)
                    : Ported from MATLAB implementation by
                      Gavin C. Cawley and Nicola L. C. Talbot
        Description : Simple python implementation of Sammon's non-linear
                      mapping algorithm [1].
        References  : [1] Sammon, John W. Jr., "A Nonlinear Mapping for Data
                      Structure Analysis", IEEE Transactions on Computers,
                      vol. C-18, no. 5, pp 401-409, May 1969.
        Copyright   : (c) Dr Gavin C. Cawley, November 2007.
        This program is free software; you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation; either version 2 of the License, or
        (at your option) any later version.
        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.
        You should have received a copy of the GNU General Public License
        along with this program; if not, write to the Free Software
        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
        """

        # Create distance matrix unless given by parameters
        if self.inputdist == 'distance':
            D = data_high
            if self.init == 'default':
                self.init = 'cmdscale'
        else:
            D = cdist(data_high, data_high)
            if self.init == 'default':
                self.init = 'pca'

        if self.inputdist == 'distance' and self.init == 'pca':
            raise ValueError("Cannot use init == 'pca' when inputdist == 'distance'")

        if np.count_nonzero(np.diagonal(D)) > 0:
            raise ValueError("The diagonal of the dissimilarity matrix must be zero")

        # Remaining initialisation
        N = data_high.shape[0]
        scale = 0.5 / D.sum()
        D = D + np.eye(N)

        if np.count_nonzero( D <= 0) > 0:
            raise ValueError("Off-diagonal dissimilarities must be strictly positive")

        Dinv = 1 / D
        if self.init == 'pca':
            [UU ,DD ,_] = np.linalg.svd(data_high)
            y = UU[: ,:self.n_components ] *DD[:self.n_components]

        elif self.init == 'cmdscale':
            from cmdscale import cmdscale
            y ,e = cmdscale(D)
            y = y[: ,:self.n_components]

        else:
            y = np.random.normal(0.0 ,1.0 ,[N ,self.n_components])
        one = np.ones([N ,self.n_components])
        d = cdist(y ,y) + np.eye(N)
        dinv = 1. / d
        delta = D- d
        E = ((delta ** 2) * Dinv).sum()

        # Get on with it
        for i in range(self.max_iter):

            # Compute gradient, Hessian and search direction (note it is actually
            # 1/4 of the gradient and Hessian, but the step size is just the ratio
            # of the gradient and the diagonal of the Hessian so it doesn't
            # matter).
            delta = dinv - Dinv
            deltaone = np.dot(delta, one)
            g = np.dot(delta, y) - (y * deltaone)
            dinv3 = dinv ** 3
            y2 = y ** 2
            H = np.dot(dinv3, y2) - deltaone - np.dot(2, y) * np.dot(dinv3, y) + y2 * np.dot(dinv3, one)
            s = -g.flatten(order='F') / np.abs(H.flatten(order='F'))
            y_old = y

            # Use step-halving procedure to ensure progress is made
            for j in range(self.maxhalves):
                s_reshape = np.reshape(s, (-1, self.n_components), order='F')
                y = y_old + s_reshape
                d = cdist(y, y) + np.eye(N)
                dinv = 1 / d
                delta = D - d
                E_new = ((delta ** 2) * Dinv).sum()
                if E_new < E:
                    break
                else:
                    s = 0.5 * s

            # Bomb out if too many halving steps are required
            if j == self.maxhalves - 1:
                print('Warning: maxhalves exceeded. Sammon mapping may not converge...')

            # Evaluate termination criterion
            if abs((E - E_new) / E) < self.tolfun:
                if self.display:
                    print('TolFun exceeded: Optimisation terminated')
                break

            # Report progress
            E = E_new
            if self.display > 1:
                print('epoch = %d : E = %12.10f' % (i + 1, E * scale))

        if i == self.max_iter - 1:
            print('Warning: maxiter exceeded. Sammon mapping may not have converged...')

        # Fiddle stress to match the original Sammon paper
        # E = E * scale

        return y